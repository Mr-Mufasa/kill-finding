import { KillClip } from '@/hooks/useKillDetection';

export interface HighlightReelSettings {
  transitionDuration: number; // seconds
  orderBy: 'chronological' | 'confidence';
  includeIntro: boolean;
  includeOutro: boolean;
  fadeTransitions: boolean;
}

export class VideoCompiler {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private mediaRecorder: MediaRecorder | null = null;
  private recordedChunks: Blob[] = [];

  constructor() {
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d')!;
  }

  async compileHighlightReel(
    sourceVideo: HTMLVideoElement,
    clips: KillClip[],
    settings: HighlightReelSettings
  ): Promise<Blob> {
    // Sort clips based on user preference
    const sortedClips = this.sortClips(clips, settings.orderBy);
    
    // Set canvas dimensions to match video
    this.canvas.width = sourceVideo.videoWidth;
    this.canvas.height = sourceVideo.videoHeight;

    // Setup media recorder
    const stream = this.canvas.captureStream(30);
    this.mediaRecorder = new MediaRecorder(stream, {
      mimeType: 'video/webm;codecs=vp9'
    });

    this.recordedChunks = [];
    this.mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        this.recordedChunks.push(event.data);
      }
    };

    // Start recording
    this.mediaRecorder.start();

    // Compile video segments
    if (settings.includeIntro) {
      await this.addIntroSegment();
    }

    for (let i = 0; i < sortedClips.length; i++) {
      const clip = sortedClips[i];
      await this.addClipSegment(sourceVideo, clip);
      
      // Add transition between clips (except for the last one)
      if (i < sortedClips.length - 1 && settings.fadeTransitions) {
        await this.addTransition(settings.transitionDuration);
      }
    }

    if (settings.includeOutro) {
      await this.addOutroSegment();
    }

    // Stop recording and return blob
    this.mediaRecorder.stop();
    
    return new Promise((resolve) => {
      this.mediaRecorder!.onstop = () => {
        const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
        resolve(blob);
      };
    });
  }

  private sortClips(clips: KillClip[], orderBy: 'chronological' | 'confidence'): KillClip[] {
    return [...clips].sort((a, b) => {
      if (orderBy === 'chronological') {
        return a.timestamp - b.timestamp;
      } else {
        return b.confidence - a.confidence;
      }
    });
  }

  private async addClipSegment(sourceVideo: HTMLVideoElement, clip: KillClip): Promise<void> {
    const startTime = Math.max(0, clip.timestamp - 2); // 2 seconds before kill
    const endTime = Math.min(sourceVideo.duration, clip.timestamp + clip.duration);
    
    return new Promise((resolve) => {
      sourceVideo.currentTime = startTime;
      
      const updateFrame = () => {
        if (sourceVideo.currentTime >= endTime) {
          resolve();
          return;
        }

        // Draw current frame to canvas
        this.ctx.drawImage(sourceVideo, 0, 0, this.canvas.width, this.canvas.height);
        
        // Add kill info overlay
        this.addKillOverlay(clip);
        
        requestAnimationFrame(updateFrame);
      };

      sourceVideo.onseeked = () => {
        sourceVideo.play();
        updateFrame();
      };
    });
  }

  private addKillOverlay(clip: KillClip): void {
    const ctx = this.ctx;
    
    // Add semi-transparent overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(this.canvas.width - 250, 20, 230, 80);
    
    // Add kill info text
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px Arial';
    ctx.fillText(`${clip.weapon} Kill`, this.canvas.width - 240, 45);
    ctx.fillText(`${clip.enemiesKilled} eliminated`, this.canvas.width - 240, 65);
    
    if (clip.isMultiKill) {
      ctx.fillStyle = '#ff6b6b';
      ctx.fillText('MULTI KILL!', this.canvas.width - 240, 85);
    }
  }

  private async addIntroSegment(): Promise<void> {
    // Simple intro with text
    this.ctx.fillStyle = '#000000';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    this.ctx.fillStyle = '#ffffff';
    this.ctx.font = 'bold 48px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('VALORANT HIGHLIGHTS', this.canvas.width / 2, this.canvas.height / 2);
    
    // Hold for 2 seconds
    await this.delay(2000);
  }

  private async addOutroSegment(): Promise<void> {
    // Simple outro with text
    this.ctx.fillStyle = '#000000';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    this.ctx.fillStyle = '#ffffff';
    this.ctx.font = 'bold 32px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('Generated by Valorant Kill Extractor', this.canvas.width / 2, this.canvas.height / 2);
    
    await this.delay(2000);
  }

  private async addTransition(duration: number): Promise<void> {
    const frames = Math.floor(duration * 30); // 30 FPS
    
    for (let i = 0; i < frames; i++) {
      const alpha = i / frames;
      this.ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      
      await this.delay(1000 / 30); // 30 FPS
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  cleanup(): void {
    if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
      this.mediaRecorder.stop();
    }
    this.recordedChunks = [];
  }
}